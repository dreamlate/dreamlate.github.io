<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="for the dream">
<meta property="og:type" content="website">
<meta property="og:title" content="冰冷的梦境">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="冰冷的梦境">
<meta property="og:description" content="for the dream">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="冰冷的梦境">
<meta name="twitter:description" content="for the dream">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>冰冷的梦境</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冰冷的梦境</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/设计模式-责任链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/设计模式-责任链/" itemprop="url">设计模式-责任链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T15:04:47+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p>&emsp;&emsp;责任链模式就是为请求创建一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。属于行为型模式。<br><br>&emsp;&emsp;每个接收者都包含下一个接收者的引用，如果该接收者不能处理该请求，那么就把该请求传递到下一个接收者。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低耦合度，将请求的发送者和接收者解耦。</li>
<li>简化了对象，使得对象不需要知道链的结构。</li>
<li>增强了给对象指派职责的灵活性，通过改变链内的成员或者调动它们的次序，允许动态的新增或者删除责任。</li>
<li>增加新的请求处理类变得很简单。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不能保证请求一定被接收。（可能所有的处理者都处理不了这个请求）</li>
<li>系统的性能将受到一定影响，而且在进行代码调试的时候会很麻烦。（比如，处理链有10个处理者，这个请求只能被最后一个处理者处理，但该请求还是要经过前面9个处理者）</li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动决定。</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交请求。</li>
<li>可动态指定一组对象处理请求。</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://raw.githubusercontent.com/dreamlate/hello-world/master/images/201801151648-chain.png" alt="image"><br>&emsp;&emsp;声明一个抽象类Logger，在Logger中声明一个抽象方法write。然后声明4个继承Logger的类，并实现write方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DebugLogger debugLogger = new DebugLogger(1);</span><br><span class="line">InfoLogger infoLogger = new InfoLogger(2);</span><br><span class="line">WarningLogger warningLogger = new WarningLogger(3);</span><br><span class="line">ErrorLogger errorLogger = new ErrorLogger(4);</span><br><span class="line">//链式关系</span><br><span class="line">debugLogger.setLogger(infoLogger);</span><br><span class="line">infoLogger.setLogger(warningLogger);</span><br><span class="line">warningLogger.setLogger(errorLogger);</span><br><span class="line"></span><br><span class="line">debugLogger.loadMessage(1,&quot;test1&quot;);</span><br><span class="line">debugLogger.loadMessage(3,&quot;test3&quot;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/设计模式-模板模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/设计模式-模板模式/" itemprop="url">设计模式-模板模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T13:30:39+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>&emsp;&emsp;在一个抽象类中公开定义执行它的方法的模板。它的子类可以按需重写方法，但调用将以抽象类中定义的方式进行。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>封装不变部分，扩展可变部分。</li>
<li>提取公共代码，便于维护。</li>
<li>行为由父类控制，子类实现。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>有多个子类有相同的方法，且逻辑相同。</li>
<li>重要的、复杂的方法，可以考虑作为模板方法。例如：spring中对hibernate封装的开启事务、获取session、关闭session等函数。</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://raw.githubusercontent.com/dreamlate/hello-world/master/images/201801151713-template.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Game dota = new Dota();</span><br><span class="line">dota.play();</span><br><span class="line">Game lol = new LOL();</span><br><span class="line">lol.play();</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.runoob.com/design-pattern/template-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/template-pattern.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/14/线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/14/线程池/" itemprop="url">线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-14T17:00:42+08:00">
                2017-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h4><ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ul>
<h4 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h4><ol>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ol>
<h4 id="ThreadPoolExecutor执行execute方法的四种情况"><a href="#ThreadPoolExecutor执行execute方法的四种情况" class="headerlink" title="ThreadPoolExecutor执行execute方法的四种情况"></a>ThreadPoolExecutor执行execute方法的四种情况</h4><ol>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步需要获取全局锁）。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意这一步需要获取全局锁）。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<h4 id="ThreadPoolExecutor的参数"><a href="#ThreadPoolExecutor的参数" class="headerlink" title="ThreadPoolExecutor的参数"></a>ThreadPoolExecutor的参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,milliseconds,runnableTaskQueue,handler);</span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本能线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</li>
<li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择一下几个阻塞队列。<ul>
<li>ArrayBlockingQueue：是一个基于数字结构的有界阻塞队列，次队列按FIFO（先进先出）原则对元素进行排序。</li>
<li>LinkedBlockingQueue：是一个基于链表机构的阻塞队列，次队列按FIFO排序元素，吞吐量通常高于ArrayBlockingQueue。静态工厂方法Executors.new FixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
<li>maximumPoolSize（线程池最大数量）：线程池运行创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没有效果了。</li>
<li>ThreadFactory：用于设置创建线程的工厂，可以用个线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字。</li>
<li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队里里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/对zookeeper的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/13/对zookeeper的理解/" itemprop="url">对zookeeper的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T20:31:50+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>zookeeper是一个开源的分布式服务。分布式应用可以基于zk实现的功能包括：数据发布/订阅、负载均衡、命名服务、集群管理、master选举、分布式锁、分布式队列等。</em></p>
<hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>&emsp;&emsp;在zookeeper中，主要有三种角色：<br></p>
<ul>
<li>leader：在一个zk集群中，同一时刻只能有一个leader。zk集群通过选举，来选定一台机器为leader，leader服务器为客户端提供读写服务。</li>
<li>follower：follower服务器能够为客户端提供读服务，其参与master选举的过程。</li>
<li>observer：oberser与follower功能几乎一样，不同的是，observer不参与master选举。其配置与follower或者leader不一样的地方在于其端口后面多了一个observer：<em>server.1=192.168.20.101:2888:3888:observer，并且设置peerType=observer</em>。++observer可以在不影响写性能的情况下提升集群的读性能++。</li>
</ul>
<h4 id="会话（session）"><a href="#会话（session）" class="headerlink" title="会话（session）"></a>会话（session）</h4><p>&emsp;&emsp;session指的是客户端会话。在zk中，一个客户端连接指的是客户端和zk服务器之间的长连接。zk对外的默认端口是2181，客户端启动时，首先会与服务器建立一个TCP长连接，从第一次连接建立开始，客户端会话的生命周期也就开始了，通过这个长连接，客户端能够通过心跳检测和服务器端保持有效的会话，能够向zk服务器发送请求并接受响应，同时还能接收来自服务器的watch事件通知。SessionTimeout用来设置一个客户端会话的超时时间。当服务器压力太大、网络故障或者是客户端主动断开连接等各种原因，只要客户端在SessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那之前创建的会话仍然有效。<br></p>
<h4 id="数据节点（ZNode）"><a href="#数据节点（ZNode）" class="headerlink" title="数据节点（ZNode）"></a>数据节点（ZNode）</h4><p>&emsp;&emsp;ZNode是zookeeper数据模型中的数据单元，zk将所有数据都存储在内存中，数据模型是一个树形结构（ZNode Tree），有斜杠（/）进行路径的分割，就是一个ZNode，例如：/root/children，其中root和children都是ZNode，root是children的父级。每个ZNode上都会保存自己的数据内容。<br><br>&emsp;&emsp;ZNode可以分为持久节点、临时节点、持久顺序节点和临时顺序节点。</p>
<ul>
<li>持久节点，可以使用create命令来创建。持久节点一旦被创建，除非主动删除，否则这个ZNode将一直保存在zookeeper上。例如：<em>create /root1 hello</em>，这样就创建了一个root1的持久节点，其数据为hello。</li>
<li>临时节点的声明周期是跟客户端会话绑定的，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。例如：<em>create -e /root2 world</em>，这样就创建了一个root2的临时节点，其数据为world，当会话关闭后，这个节点就会被删除。</li>
<li>持久顺序节点，和顺序节点的特性基本一致，唯一不同的是，每个父节点会为它的第一级子节点维护一份时序，记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，zk会自动为给定节点加上一个数字后缀，作为新的节点，数字后缀的范围是整型的最大值。例如：<em>create -s /root3/hello hello</em>，会输出：<em>created /root3/hello0000000001</em>。</li>
<li>临时顺序节点，其包含了临时节点和顺序节点的特性。创建方式：<em>create -s -e /root4/world world</em>，创建后的节点为<em>world00000000001</em>。</li>
</ul>
<h4 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid = 0x1313f3d4d9</span><br><span class="line">ctime = Wed Aug 17 15:10:00 CST 2016</span><br><span class="line">mZxid = 0x28b8c53eb5</span><br><span class="line">mtime = Thu Aug 17 14:13:05 CST 2017</span><br><span class="line">pZxid = 0x294c791a36</span><br><span class="line">cversion = 13</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 28</span><br><span class="line">numChildren = 11</span><br></pre></td></tr></table></figure>
<ul>
<li>cZxid：znode创建的事务id。</li>
<li>ctime：znode创建的时间。</li>
<li>mZxid：znode被修改的事务id，每次对znode的修改都会更新该值。</li>
<li>mtime：znode更新的时间。</li>
<li>pZxid：与znode的子节点有关，表示其子节点最近一次创建或者删除的时间。注意只有子节点列表变更才会更新pZxid，子节点内容变更不会影响pZxid。</li>
<li>cversion：子节点版本号，当znode子节点有变化时，cversion的值就会增加一。</li>
<li>dataVersion：数据版本号，每次对节点进行set操作，dataVersion的值都会加一。</li>
<li>aclVersion：Access Control List（访问控制）的版本号。</li>
<li>ephemeralOwner：如果该节点为临时节点，ephemeralOwner的值表示与该节点绑定的session id。如果该节点不是临时节点，ephemeralOwner的值为0。</li>
<li>dataLength：节点数据的字节数。</li>
<li>numChildren：子节点数量。</li>
</ul>
<p>&emsp;&emsp;在zk中，能改变zk服务器状态的操作被称为事务操作。一般包括数据节点的创建、删除、数据内容更新和客户端会话创建与失效等操作。对每一个事务请求，zk都会为其分配一个全局唯一的事务id，用zxid表示，通常是一个64位的数字。每个zxid对应一次更新操作，从zxid中可以间接识别出zk处理这些事务操作请求的全局顺序。</p>
<h4 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h4><p>&emsp;&emsp;watcher是zk中一个很重要的特性。zk允许用户在指定节点上注册一些watcher，并且在一些特定事件触发的时候，zk服务端会将事件通知到感兴趣的客户端上去。该机制是zk实现分布式协调服务的重要特性。</p>
<h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>&emsp;&emsp;zk采用ACL（Access Control Lists）策略来进行权限控制。zk定义了5中权限：</p>
<ul>
<li>CREATE：创建子节点的权限。</li>
<li>READ：获取节点数据和子节点列表的权限。</li>
<li>WRITE：更新节点数据的权限。</li>
<li>DELETE：删除子节点的权限。</li>
<li>ADMIN：设置节点ACL的权限。</li>
</ul>
<p>注意：CREATE和DELETE都是针对子节点的权限控制。</p>
<hr>
<h2 id="功能场景"><a href="#功能场景" class="headerlink" title="功能场景"></a>功能场景</h2><p>zk是一个高可用的分布式数据管理与协调框架。基于ZAB算法的实现，该框架能够很好的保证分布式环境中数据的一致性。</p>
<h3 id="数据发布-订阅"><a href="#数据发布-订阅" class="headerlink" title="数据发布/订阅"></a>数据发布/订阅</h3><p>&emsp;&emsp;数据发布/订阅就是通常所说的<strong>配置中心</strong>，发布者将数据发布到zk节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和动态更新。<br>&emsp;&emsp;在系统开发中，经常会有这样的需求：系统需要使用一些通用的配置信息，例如服务器列表信息、数据库配置信息等。这些全局配置信息通常有以下三个特性。</p>
<ul>
<li>数据量通常比较小。</li>
<li>数据内容在运行时动态变化。</li>
<li>集群中各个服务器共享，配置一致。</li>
</ul>
<p>&emsp;&emsp;对于这样的全局配置信息就可以发布到zk上，上客户端去订阅该消息。发布\订阅系统一般有两种设计模式，分别是推（push）和拉（pull）模式。<br><br>&emsp;&emsp;推：服务器端主动将数据更新发给所有订阅的客户端。拉：客户端主动发起请求来获取最新数据，通常客户端采用定时轮询拉取的方式。<br>&emsp;&emsp;zk采用的是推拉结合的方式。如下：客户端想服务端注册自己需要关注的节点，一旦该节点的数据发生变更，那么服务器端就会向相应的客户端发送watcher事件通知，客户端收到这个消息后，需要主动到服务器端获取最新的数据（推拉结合）。</p>
<h3 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h3><p>&emsp;&emsp;命名服务是分布式系统中比较常见的一种场景。在分布式系统中，使用命名服务，客户端应用能够根据指定名字来获取资源或者服务的地址、提供者等信息。被命名的实体通常可以是集群中的机器、提供的服务、远程对象等等。较为常见的就是一些分布式服务框架中的服务地址列表。通过在zk里创建顺序节点，能够很容易创建一个全局唯一的路径，这个路径就可以作为一个名字。</p>
<h3 id="master选举"><a href="#master选举" class="headerlink" title="master选举"></a>master选举</h3><p>&emsp;&emsp;master选举是zk最典型的应用场景。利用zk的强一致性，能够很好的保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即zk将保证客户端无法创建一个已经存在的znode。如果多个客户端请求创建一个临时节点，那么最终一定只有一个客户端请求能够创建成功。利用这个特性，能够在分布式环境中进行master选举了。<br><br>&emsp;&emsp;成功创建该节点的客户端所在的机器就成为了Master。同时，其他没有成功创建该节点的客户端，都会在该节点上注册一个子节点变更的Watcher，用于监控当前Master机器是否存活，一旦发现当前的Master挂了，那么其他客户端将会重新进行Master选举。这样就实现了Master的动态选举。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>&emsp;&emsp;分布式锁是控制分布式系统之间同步访问共享资源的一种方式。分布式锁可以分为排他锁和共享锁两种。<br></p>
<ul>
<li>排他锁，简称X锁，又称写锁或者独占锁。<em>如果事务T1对数据对象O1加上了排他锁，那么在整个加锁期间，只允许事务T1对O1进行读取和更新操作，其他任何事务都不能在对这个数据对象进行任何类型的操作，不能再对该对象加锁，直到T1释放了排他锁。</em>排他锁的核心是如何保证当前只有一个事务获得锁，并且锁被释放后，所有正在等待获取锁的事务都能被通知到。</li>
<li>共享锁，简称S锁，又称为读锁。如果事务T1对数据对象O1加上了共享锁，那么T1只能对O1进行读操作，其他事务也能同事对O1加共享锁（排他锁不行），直到O1上的所有共享锁都释放后O1才能被加排他锁。<br></li>
</ul>
<p>&emsp;&emsp;总结：++可以多个事务同时获得一个对象的共享锁，有共享锁就不能再加排他锁。++</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h3><hr>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：<br></h2><ul>
<li>从PAXOS到ZOOKEEPER分布式一致性原理与实践</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/12/zookeeper伪分布式配置与遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/12/zookeeper伪分布式配置与遇到的问题/" itemprop="url">zookeeper伪分布式配置与遇到的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-12T09:12:51+08:00">
                2017-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;zookeeper提供了单机、分布式和伪分布式三种模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#zookeeper的默认配置文件zoo.cfg：</span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/tmp/zookeeper</span><br><span class="line">clientPort=2181</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;条件有限，以伪分布式为例，将zookeeper文件夹复制三份，基本配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#第一个</span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">#我本机的目录</span><br><span class="line">dataDir=D:/zookeeper/zookeeper-3.4.9-1/data</span><br><span class="line">dataLogDir=D:/zookeeper/zookeeper-3.4.9-1/logs</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=localhost:7888:8888 </span><br><span class="line">server.2=localhost:7889:8889 </span><br><span class="line">server.3=localhost:7889:8890</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#第二个</span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">#我本机的目录</span><br><span class="line">dataDir=D:/zookeeper/zookeeper-3.4.9-2/data</span><br><span class="line">dataLogDir=D:/zookeeper/zookeeper-3.4.9-2/logs</span><br><span class="line">clientPort=2182</span><br><span class="line">server.1=localhost:7888:8888 </span><br><span class="line">server.2=localhost:7889:8889 </span><br><span class="line">server.3=localhost:7889:8890</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#第三个</span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">#我本机的目录</span><br><span class="line">dataDir=D:/zookeeper/zookeeper-3.4.9-3/data</span><br><span class="line">dataLogDir=D:/zookeeper/zookeeper-3.4.9-3/logs</span><br><span class="line">clientPort=2183</span><br><span class="line">server.1=localhost:7888:8888 </span><br><span class="line">server.2=localhost:7889:8889 </span><br><span class="line">server.3=localhost:7889:8890</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;伪分布式和分布式配置的区别在于，<strong>伪分布式配置IP地址相同，端口号不同</strong>。<br><br>&emsp;&emsp;其中，localhost:7889:8890，第一个端口号用来通信，第二个端口号用来进行leader选举。</p>
<p>&emsp;&emsp;windows系统使用%zk_home%/bin目录下的zkServer.cmd启动zookeeper。由于在伪分布式下部署了三个节点，所以依次进入每个文件夹中，启动zookeeper。启动的时候可能会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2017-02-09 14:21:38,871 [myid:] - ERROR [main:QuorumPeerMain@85] - Invalid confi</span><br><span class="line">g, exiting abnormally</span><br><span class="line">org.apache.zookeeper.server.quorum.QuorumPeerConfig$ConfigException: Error proce</span><br><span class="line">ssing D:\zookeeper\zookeeper-3.4.9-1\bin\..\conf\zoo.cfg</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumPeerConfig.parse(QuorumPeerC</span><br><span class="line">onfig.java:144)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumPeerMain.initializeAndRun(Qu</span><br><span class="line">orumPeerMain.java:101)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumPeerMain.main(QuorumPeerMain</span><br><span class="line">.java:78)</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: D:\zookeeper\zookeeper-3.4.9-1\da</span><br><span class="line">ta\myid file is missing</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumPeerConfig.parseProperties(Q</span><br><span class="line">uorumPeerConfig.java:362)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumPeerConfig.parse(QuorumPeerC</span><br><span class="line">onfig.java:140)</span><br><span class="line">        ... 2 more</span><br><span class="line">Invalid config, exiting abnormally</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;错误原因是没有找到myid这个文件（如11、12行），需要在配置文件dataDir指定的目录下面（我的是：D:\zookeeper\zookeeper-3.4.9-1\data）建立一个myid文件，内容为1。依次在剩下的两个文件夹中也建立一个myid的文件，内容分别为2和3。</p>
<p>&emsp;&emsp;保存后，再次启动，发现又出现异常了，异常比较多，仅截取部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">2017-02-09 14:32:32,467 [myid:1] - WARN  [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:218</span><br><span class="line">1:QuorumCnxManager@400] - Cannot open channel to 3 at election address localhost</span><br><span class="line">/127.0.0.1:8890</span><br><span class="line">java.net.ConnectException: Connection refused: connect</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketI</span><br><span class="line">mpl.java:85)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.ja</span><br><span class="line">va:350)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocket</span><br><span class="line">Impl.java:206)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java</span><br><span class="line">:188)</span><br><span class="line">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(Quorum</span><br><span class="line">CnxManager.java:381)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectAll(Quorum</span><br><span class="line">CnxManager.java:426)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.FastLeaderElection.lookForLeader(F</span><br><span class="line">astLeaderElection.java:843)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumPeer.run(QuorumPeer.java:822</span><br><span class="line">)</span><br><span class="line">2017-02-09 14:32:32,623 [myid:1] - INFO  [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:218</span><br><span class="line">1:QuorumPeer$QuorumServer@149] - Resolved hostname: localhost to address: localh</span><br><span class="line">ost/127.0.0.1</span><br><span class="line">2017-02-09 14:32:32,623 [myid:1] - INFO  [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:218</span><br><span class="line">1:FastLeaderElection@852] - Notification time out: 12800</span><br><span class="line">2017-02-09 14:32:46,468 [myid:1] - WARN  [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:218</span><br><span class="line">1:QuorumCnxManager@400] - Cannot open channel to 2 at election address localhost</span><br><span class="line">/127.0.0.1:8889</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个异常其实可以忽略，仔细看2、3、31、32行打印出的信息就明白了。出现这个异常的原因是因为，现在只启动了一个zk节点，而在配置文件中却写了三个zk的地址，第一个zk节点还无法与剩下的两个节点进行通信，所以只要把三个zk节点都启动就没问题了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/29/http-and-https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/29/http-and-https/" itemprop="url">http and https</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-29T21:01:23+08:00">
                2017-01-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>http是http协议运行在tcp之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</li>
<li>https是http运行在ssl/tls之上，ssl/tls运行在tcp之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的秘钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。</li>
<li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的完全不同的连接方式，用的端口也不一样，前者是80，后者是443.</li>
<li>http的链接简单，是无状态的。</li>
<li>https协议有ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/28/TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/28/TCP/" itemprop="url">TCP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-28T21:52:02+08:00">
                2017-01-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h3><ul>
<li>数据报校验</li>
<li>超时重传机制</li>
<li>应答机制</li>
<li>对失序数据包重排序</li>
<li>TPC还能提供流量控制</li>
</ul>
<h3 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://raw.githubusercontent.com/dreamlate/hello-world/master/images/201801271114-tcp1.png" alt="image"></p>
<h3 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h3><ul>
<li>第一次握手：client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给server，client进入SYN_SENT状态，等待server确认。</li>
<li>第二次握手：server收到数据包后由标志位SYN=1知道client请求连接，server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值sep=K，并将该数据包发送给client以确认连接请求，server进入SYN_RCVD状态。</li>
<li>第三次握手：client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则连接建立成功，client和server进入established状态，完成三次握手，随后client和server之间可以开始传输数据了。</li>
</ul>
<h3 id="三次握手原因"><a href="#三次握手原因" class="headerlink" title="三次握手原因"></a>三次握手原因</h3><p>&emsp;&emsp;为了防止失效的链接请求报文突然又传到了服务端，因而产生错误。例如：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文并没有丢失，而是在某个网络节点长时间滞留，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。当server却以为新的运输连接已经建立，并一直等待client发来数据。这样，sever的很多资源就白白浪费了。采用三次握手可以防止上述现象的发生。例如刚才那种情况，client不会向server发出确认。server由于收不到确认，就知道client并没有要求建立连接。<br><br>&emsp;&emsp;通过三次握手可以确认客户端和服务器端的收发功能是否正常。client确认了：自己发送、接收正常，对方发送、接收正常；server确认了：自己发送、接收正常，对方发送、接收正常。</p>
<h3 id="DDos攻击"><a href="#DDos攻击" class="headerlink" title="DDos攻击"></a>DDos攻击</h3><p>&emsp;&emsp;client不断向sever发送请求，server会给每个请求创建一个连接，然后向client发送创建链接时的回复，然后进行等待客户端发送第三次握手数据包。DDos攻击就是这样的原理，第一个D表示的是分布式distribute。让server产生大量的等待client回复的连接，浪费系统资源，并且会使正常的请求进不来。<br><br>&emsp;&emsp;简单说服务器发送连接请求，首先：</p>
<ol>
<li>客户端向服务器端发送连接请求的数据包（第一次握手）。</li>
<li>服务器向客户端回复连接请求数据包（第二次握手）。然后服务器等待客户端发送tcp/ip连接的第三步数据包（第三次握手）。</li>
<li>如果客户端不向服务器端发送最后一个数据包，则服务器必须等待30s-2min才能将此连接关闭。当大量的请求只进行到了第二步，而不进行第三步，服务器又有大量资源在等待第三个数据包。最后就造成了DDos攻击。</li>
</ol>
<h3 id="预防ddos攻击（没有根治办法，除非不用tcp-ip）"><a href="#预防ddos攻击（没有根治办法，除非不用tcp-ip）" class="headerlink" title="预防ddos攻击（没有根治办法，除非不用tcp/ip）"></a>预防ddos攻击（没有根治办法，除非不用tcp/ip）</h3><ul>
<li>确保服务器的系统文件是最新版本，并及时更新系统补丁</li>
<li>关闭不必要的服务</li>
<li>限制同时打开SYN的半连接数目</li>
<li>缩短SYN半连接的time out时间</li>
<li>正确设置防火墙</li>
<li>禁止对主机的非开放服务访问</li>
<li>限制特点IP短地址的访问</li>
<li>启用防火墙防DDos的属性</li>
<li>严格限制对外开放的服务器的向外扫描</li>
<li>运行端口映射程序或端口扫描程序，要认真检查特权端口和非特权端口。</li>
<li>认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更，那这台机器就可能遭到了攻击。</li>
<li>限制在防火墙外与网络文件共享，这样会给黑客截取系统文件的机会，主机的信息会暴露给黑客，无意给了对方入侵的机会。</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://raw.githubusercontent.com/dreamlate/hello-world/master/images/201801271115-tcp2.png" alt="image"></p>
<h3 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h3><p>&emsp;&emsp;由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<ul>
<li>第一次挥手：client发送一个FIN，用来关闭client到server的数据发送，client进入FIN_WAIT_1状态。</li>
<li>第二次挥手：server收到FIN后，发送一个ACK给client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号，server进入CLOSE_WAIT）。</li>
<li>第三次挥手：server发送一个FIN，用来关闭server到client的数据传送，server进入LAST_ACK状态。</li>
<li>第四次挥手：client收到FIN后，client进入TIME_WAIT状态，接着发送一个ACK给server，确认序号为收到序号+1，server进入CLOSED状态，完成四次挥手。</li>
</ul>
<h3 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h3><p>&emsp;&emsp;TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>
<h4 id="为什么建立连接是三次握手，而关闭连接却是四次挥手"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手</h4><p>&emsp;&emsp;这是因为服务器端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，收到对方的FIN报文时，仅仅表示对方不在发送数据了但是还能接受数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><ul>
<li>UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</li>
<li>UDP是面向报文的，UDP没有拥塞控制，很合适多媒体通信的要求。</li>
<li>UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>UDP的首部开销小，只有8个字节。</li>
<li>TCP是面向连接的运输层协议。每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。</li>
<li>TCP提供可靠交付的服务。</li>
<li>TCP提供全双工通信。</li>
<li>TCP面向字节流。</li>
<li>首部最低20个字节。</li>
</ul>
<hr>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="http://blog.csdn.net/renzhenhuai/article/details/12105457" target="_blank" rel="noopener">http://blog.csdn.net/renzhenhuai/article/details/12105457</a></li>
<li><a href="http://blog.csdn.net/daguairen/article/details/52673194" target="_blank" rel="noopener">http://blog.csdn.net/daguairen/article/details/52673194</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/28/HTTP长连接和短连接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/28/HTTP长连接和短连接/" itemprop="url">HTTP长连接和短连接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-28T13:56:27+08:00">
                2017-01-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTTP协议与TCP-IP协议的关系"><a href="#HTTP协议与TCP-IP协议的关系" class="headerlink" title="HTTP协议与TCP/IP协议的关系"></a>HTTP协议与TCP/IP协议的关系</h3><p>&emsp;&emsp;http长连接和短连接本质上是TCP长连接和短连接。http属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。</p>
<h3 id="HTTP协议是无状态"><a href="#HTTP协议是无状态" class="headerlink" title="HTTP协议是无状态"></a>HTTP协议是无状态</h3><p>&emsp;&emsp;无状态指的是对于事务没有处理记忆能力，服务器不知道客户端是什么状态。也就是说，在同一个web站点10分钟前打开一个页面和现在打开一个页面，它们之间是没有任何联系的。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的UDP协议。</p>
<h3 id="长连接、短连接"><a href="#长连接、短连接" class="headerlink" title="长连接、短连接"></a>长连接、短连接</h3><p>&emsp;&emsp;在HTTP/1.0中默认使用的是短连接。也就是说，客户端每次和服务器进行http操作，就会建立一次连接，任务结束连接也就中断。比如，访问某个页面，页面中包含图片、css、js等多个资源，这样的话，会建立多次连接。<br>&emsp;&emsp;而在HTTP/1.1中，默认使用了长连接，保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码  Connection:keep-alive。<br>&emsp;&emsp;在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用户传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这条已经建立的连接。keep-alive不会永久保持连接，他有一个保持时间，可以在不同的服务器软件中设定。实现长连接需要客户端和服务器端都支持长连接。</p>
<h3 id="长连接和短连接的优缺点"><a href="#长连接和短连接的优缺点" class="headerlink" title="长连接和短连接的优缺点"></a>长连接和短连接的优缺点</h3><p>&emsp;&emsp;长连接可以省去较多的TCP建立和关闭操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。<br><br>&emsp;&emsp;短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。<br><br>&emsp;&emsp;短连接的操作步骤是：<br><br>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接<br><br>&emsp;&emsp;长连接的操作步骤是：<br><br>建立连接——数据传输…（保持连接）…数据传输——关闭连接<br></p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cnblogs.com/cswuyg/p/3653263.html" target="_blank" rel="noopener">http://www.cnblogs.com/cswuyg/p/3653263.html</a></li>
<li><a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">https://www.cnblogs.com/gotodsp/p/6366163.html</a></li>
<li><a href="http://www.cnblogs.com/0201zcr/p/4694945.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/4694945.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/06/dubbo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/06/dubbo/" itemprop="url">dubbo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-06T22:57:41+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">Dubbo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="dubbo的基本需求"><a href="#dubbo的基本需求" class="headerlink" title="dubbo的基本需求"></a>dubbo的基本需求</h3><ul>
<li>动态的注册和发现服务，实现软负载，降低对F5硬件负载的依赖。</li>
<li>理清服务间的依赖关系。</li>
<li>统计每个服务的调用量、相应时间。可以动态调整每个机器的权重。</li>
</ul>
<h3 id="dubbo的架构"><a href="#dubbo的架构" class="headerlink" title="dubbo的架构"></a>dubbo的架构</h3><p><img src="https://raw.githubusercontent.com/dreamlate/hello-world/master/images/201701110931-dubbo-architecture.jpg" alt="image"><br>节点 | 角色说明<br>—|—<br>provider | 暴露服务的服务提供方<br>consumer | 调用远程服务的服务消费方<br>registry | 服务注册于发现的注册中心<br>Monitor  | 统计服务的调用次数和调用时间的监控中心<br>Container| 服务运行容器</p>
<h4 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h4><ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，在选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<p><em>dubbo架构具有以下几个特点：分别是连通性、健壮性、伸缩性以及未来架构的升级性。</em></p>
<h4 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h4><ul>
<li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</li>
<li>监控中心负责统计各个服务的调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示。</li>
<li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销。</li>
<li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法之间调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销。</li>
<li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外。</li>
<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者。</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</li>
</ul>
<h4 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h4><ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据。</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务。</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台。</li>
<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯。</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用。</li>
<li>服务提供者全部宕掉后，服务消费者应有将无法使用，并无限次重连等待服务提供者恢复。</li>
</ul>
<h4 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h4><ul>
<li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心。</li>
<li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者。</li>
</ul>
<h4 id="升级性"><a href="#升级性" class="headerlink" title="升级性"></a>升级性</h4><p>&emsp;&emsp;当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：<br><br><img src="https://raw.githubusercontent.com/dreamlate/hello-world/master/images/201801111005-dubbo-architecture-future.jpg" alt="image"></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Deployer</td>
<td>自动部署服务的本地代理</td>
</tr>
<tr>
<td>Repository</td>
<td>仓库用于存储服务应用发布包</td>
</tr>
<tr>
<td>Scheduler</td>
<td>调度中心基于服务压力自动增减服务提供者</td>
</tr>
<tr>
<td>Admin</td>
<td>统一管理控制台</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用压力的监控中心</td>
</tr>
</tbody>
</table>
<h3 id="基于spring的配置"><a href="#基于spring的配置" class="headerlink" title="基于spring的配置"></a>基于spring的配置</h3><p>1.本地配置很简单，和使用本地的service类，没有区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“xxxService” class=“com.xxx.XxxServiceImpl” /&gt;</span><br><span class="line">&lt;bean id=“xxxAction” class=“com.xxx.XxxAction”&gt;</span><br><span class="line">    &lt;property name=“xxxService” ref=“xxxService” /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>2.远程配置需要将本地的配置拆分成两份，将服务定义部分放在服务提供方remote-provider.xml，将服务引用部分放在服务消费方remote-consumer.xml；并在提供方增加暴露服务配置<dubbo:service>，在消费方增加引用服务配置<dubbo:reference>。<br><br>remote-provider.xml:</dubbo:reference></dubbo:service></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 和本地服务一样实现远程服务;加上url=&quot;ip:port&quot;，相当于直连，不经过注册中心，一般本地调试的时候，会设置成localhost --&gt;</span><br><span class="line">&lt;bean id=“xxxService” class=“com.xxx.XxxServiceImpl” /&gt; </span><br><span class="line">&lt;!-- 增加暴露远程服务配置 --&gt;</span><br><span class="line">&lt;dubbo:service interface=“com.xxx.XxxService” ref=“xxxService” /&gt;</span><br></pre></td></tr></table></figure>
<p>remote-consumer.xml:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 增加引用远程服务配置 --&gt;</span><br><span class="line">&lt;dubbo:reference id=“xxxService” interface=“com.xxx.XxxService” /&gt;</span><br><span class="line">&lt;!-- 和本地服务一样使用远程服务 --&gt;</span><br><span class="line">&lt;bean id=“xxxAction” class=“com.xxx.XxxAction”&gt; </span><br><span class="line">    &lt;property name=“xxxService” ref=“xxxService” /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><h4 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h4><table>
<thead>
<tr>
<th>标签</th>
<th>用途</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><dubbo:service></dubbo:service></td>
<td>服务配置</td>
<td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td>
</tr>
<tr>
<td><dubbo:reference></dubbo:reference></td>
<td>引用配置</td>
<td>用于创建一个远程服务代理，一个引用可以指向多个注册中心</td>
</tr>
<tr>
<td><dubbo:protocol></dubbo:protocol></td>
<td>协议配置</td>
<td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>
</tr>
<tr>
<td><dubbo:application></dubbo:application></td>
<td>应用配置</td>
<td>用于配置当前的应用信息，不管该应用是提供者还是消费者</td>
</tr>
<tr>
<td><dubbo:module></dubbo:module></td>
<td>模块配置</td>
<td>用于配置当前模块信息，可选</td>
</tr>
<tr>
<td><dubbo:registry></dubbo:registry></td>
<td>注册中心配置</td>
<td>用于配置连接注册中心相关信息</td>
</tr>
<tr>
<td><dubbo:monitor></dubbo:monitor></td>
<td>监控中心配置</td>
<td>用于配置连接监控中心相关信息，可选</td>
</tr>
<tr>
<td><dubbo:provider></dubbo:provider></td>
<td>提供方配置</td>
<td>当ProtocolConfig和ServerConfig某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td><dubbo:comsumer></dubbo:comsumer></td>
<td>消费方配置</td>
<td>当ReferenceConfig某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td><dubbo:method></dubbo:method></td>
<td>方法配置</td>
<td>用于ServiceConfig和ReferenceConfig指定方法级的配置信息</td>
</tr>
<tr>
<td><dubbo:argument></dubbo:argument></td>
<td>参数配置</td>
<td>用于指定方法参数配置</td>
</tr>
</tbody>
</table>
<p><strong><em>配置覆盖关系</em></strong><br></p>
<ul>
<li>方法级优先，接口级次之，全局配置再次之。</li>
<li>如果级别一样，则消费方优先，提供方次之。</li>
</ul>
<p>&emsp;&emsp;服务提供方的配置，通过URL经过注册中心传递给消费方。<br><br>&emsp;&emsp;下图以timeout参数为例，展示了参数配置的传递过程：<br><br><img src="https://raw.githubusercontent.com/dreamlate/hello-world/master/images/201801111428-dubbo-config-override.jpg" alt="image"></p>
<h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><p>&emsp;&emsp;如果公共配置很简单，没有多注册中心，多协议等情况，或者想多个 Spring 容器想共享配置，可以使用 dubbo.properties 作为缺省配置。<br><br>&emsp;&emsp;Dubbo 将自动加载 classpath 根目录下的 dubbo.properties，可以通过JVM启动参数 -Ddubbo.properties.file=xxx.properties 改变缺省配置位置。<br></p>
<h3 id="API配置"><a href="#API配置" class="headerlink" title="API配置"></a>API配置</h3><p>略</p>
<h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>略</p>
<p>==实际开发中，使用xml配置居多，至少我们公司是这样。==</p>
<h3 id="dubbo负载均衡策略"><a href="#dubbo负载均衡策略" class="headerlink" title="dubbo负载均衡策略"></a>dubbo负载均衡策略</h3><h4 id="Random-LoadBalance"><a href="#Random-LoadBalance" class="headerlink" title="Random LoadBalance"></a>Random LoadBalance</h4><ul>
<li>随机，按权重设置随机概率。</li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
<h4 id="RoundRobin-LoadBalance"><a href="#RoundRobin-LoadBalance" class="headerlink" title="RoundRobin LoadBalance"></a>RoundRobin LoadBalance</h4><ul>
<li>轮循，按公约后的权重设置轮循比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那里，久而久之，所有请求都卡在调第二台上。</li>
</ul>
<h4 id="LeastActive-LoadBalance"><a href="#LeastActive-LoadBalance" class="headerlink" title="LeastActive LoadBalance"></a>LeastActive LoadBalance</h4><ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
<h4 id="ConsistentHash-LoadBalance"><a href="#ConsistentHash-LoadBalance" class="headerlink" title="ConsistentHash LoadBalance"></a>ConsistentHash LoadBalance</h4><ul>
<li>一致性hash，相同参数的请求总是发送到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/27/MyBatis与SQL注入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dreamlate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰冷的梦境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/27/MyBatis与SQL注入/" itemprop="url">MyBatis与SQL注入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-27T21:38:37+08:00">
                2016-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="MyBatis中-与-的区别"><a href="#MyBatis中-与-的区别" class="headerlink" title="MyBatis中#{}与${}的区别"></a>MyBatis中#{}与${}的区别</h4><p>&emsp;&emsp;在mybatis中#{}可以防止SQL注入而${}不可以。举个例子：<em><a href="http://www.xx.com/news.jsp?id=1" target="_blank" rel="noopener">http://www.xx.com/news.jsp?id=1</a></em> 。这里的sql语句中如果使用${}，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT title,content FROM news WHERE id = $&#123;id&#125;；</span><br></pre></td></tr></table></figure></p>
<p>执行时，参数id会被直接拼接入sql语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT title,content FROM news WHERE id = 1</span><br></pre></td></tr></table></figure></p>
<p>如果攻击者提交的参数为“id=1 and 1=2 UNION SELECT username, password FROM admin”。拼接的sql语句就变为了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT title,content FROM news WHERE id = 1 and 1=2 UNION SELECT username, password FROM admin</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这条sql的原意就会被改变，导致将管理员数据表中的用户显示在页面title位置，密码显示在页面content位置，达到成功攻击的效果。而如果用#{},<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT title,content FROM news WHERE id = #&#123;id&#125;</span><br></pre></td></tr></table></figure></p>
<p>在用户提交参数之前，sql语句会进行一次预编译，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT title,content FROM news WHERE id = ?</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;攻击者提交的参数中包含的sql编译字符，不会被带入sql进行编译，只作为参数，不能造成sql注入。而且由于只进行一次预编译，sql的性能也会得到提升。在项目中，大部分SQL语句对参数的处理方式都是用了#{}这种预编译方式。但在模糊查询中，使用#{}会报错。所以使用了${ }方式代替#{}，其实在项目中可以使用concat的方式，进行参数的拼接。</p>
<h4 id="MyBatis框架下易产生SQL注入漏洞场景分析"><a href="#MyBatis框架下易产生SQL注入漏洞场景分析" class="headerlink" title="MyBatis框架下易产生SQL注入漏洞场景分析"></a>MyBatis框架下易产生SQL注入漏洞场景分析</h4><p>&emsp;&emsp;MyBatis框架下易产生SQL注入漏洞的情况主要分为以下三种：</p>
<h5 id="模糊查询like"><a href="#模糊查询like" class="headerlink" title="模糊查询like"></a>模糊查询like</h5><p>&emsp;&emsp;以按照标题进行模糊查询为例，如果考虑安全编码规范问题，其对应的SQL语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where title like &apos;%#&#123;title&#125;%&apos;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但由于这样写程序会报错，所以将SQL查询语句修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where title like &apos;%$&#123;title&#125;%&apos;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这种情况下程序不再报错，但是此时产生了SQL语句拼接问题，如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</p>
<h5 id="in之后的参数"><a href="#in之后的参数" class="headerlink" title="in之后的参数"></a>in之后的参数</h5><p>&emsp;&emsp;在进行同条件多值查询的时候，如当用户输入1001,1002,1003…100N时，如果考虑安全编码规范问题，其对应的SQL语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id in (#&#123;id&#125;)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但由于这样写程序会报错，研发人员将SQL查询语句修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id in ($&#123;id&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;修改SQL语句之后，程序停止报错，但是却引入了SQL语句拼接的问题，如果没有对用户输入的内容做过滤，势必会产生SQL注入漏洞。</p>
<h5 id="order-by之后"><a href="#order-by之后" class="headerlink" title="order by之后"></a>order by之后</h5><p>&emsp;&emsp;当根据发布时间、点击量等信息进行排序的时候，如果考虑安全编码规范问题，其对应的SQL语句如下：<br>　　　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where title =‘test’ order by #&#123;time&#125; asc</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但由于这样写程序会报错，将SQL查询语句修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where title =‘test’ order by $&#123;time&#125; asc</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;修改之后，程序通过预编译，但是产生了SQL语句拼接问题，极有可能引发SQL注入漏洞。</p>
<h4 id="Mybatis框架下SQL注入漏洞修复建议"><a href="#Mybatis框架下SQL注入漏洞修复建议" class="headerlink" title="Mybatis框架下SQL注入漏洞修复建议"></a>Mybatis框架下SQL注入漏洞修复建议</h4><h5 id="模糊查询like-SQL注入修复建议"><a href="#模糊查询like-SQL注入修复建议" class="headerlink" title="模糊查询like SQL注入修复建议"></a>模糊查询like SQL注入修复建议</h5><p>&emsp;&emsp;按照标题进行模糊查询，可将SQL查询语句设计如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where tile like concat(&apos;%&apos;,#&#123;title&#125;, &apos;%&apos;)</span><br></pre></td></tr></table></figure></p>
<p>采用预编译机制，避免了SQL语句拼接的问题，从根源上防止了SQL注入漏洞的产生。</p>
<h5 id="in之后的参数SQL注入修复建议"><a href="#in之后的参数SQL注入修复建议" class="headerlink" title="in之后的参数SQL注入修复建议"></a>in之后的参数SQL注入修复建议</h5><p>&emsp;&emsp;在对进行同条件多值查询的时候，可使用Mybatis自带循环指令解决SQL语句动态拼接的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id in</span><br><span class="line">&lt;foreach collection=&apos;ids&apos; item=&apos;item&apos; open=&apos;(&apos; separator=&apos;,&apos; close=&apos;)&apos;&gt;</span><br><span class="line">    #&#123;item&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure>
<h5 id="order-by-SQL注入修复建议–在Java层面做映射"><a href="#order-by-SQL注入修复建议–在Java层面做映射" class="headerlink" title="order by SQL注入修复建议–在Java层面做映射"></a>order by SQL注入修复建议–在Java层面做映射</h5><p>&emsp;&emsp;预编译机制只能处理查询参数，其他地方还需要研发人员根据具体情况来解决。如前面提到的排序情景：<br>　　　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where title =‘test’ order by #&#123;time&#125; asc</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里无法使用预编译机制，只能这样拼接：<br>　　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where title =‘title’ order by $&#123;time&#125; asc</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;针对这种情况可以在java层面做映射来进行解决。如当存在发布时间time和点击量click两种排序选择时，可以限制用户只能输入1和2。当用户输入1时，在代码层面将其映射为time，当用户输入2时，将其映射为click。而当用户输入1和2之外的其他内容时，可以将其转换为默认排序选择time(或者click)。</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>公司内部分享</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/user.png"
               alt="dreamlate" />
          <p class="site-author-name" itemprop="name">dreamlate</p>
           
              <p class="site-description motion-element" itemprop="description">for the dream</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dreamlate</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
